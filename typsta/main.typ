#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()
#set page(
  paper: "a4",
  numbering: "1"
)
#set par(
  justify: true,
  first-line-indent: 1em,
)
#let bold(body) = text(weight: "bold")[#body]
#let size-d(s, body) = text(size: s * 1pt)[#body]
#set text(
  font: "Times New Roman",
  size: 15pt,
)
#align(center)[
  #text(size: 17pt)[#bold[Рекурсія в `C#`]]\n

  #size-d(14,[Що потрібно знати для того щоб зрозуміти рекурсію?])
]
#v(1cm)
#size-d(17,[
1. Функції та методи в #bold[`C#`]
   - #bold[Оголошення методів]
     - #bold[`public`,] `static` #bold[,`void`, `return type`]
   - #bold[Аргументи та параметри]
   - Рекурсивний виклик функції всередині самої себе
2. Умовні конструкції
   - #bold[`if`, `else`, `switch`]
3. Цикли
   - #bold[`for`, `while`, `foreach`]
4. Змінні, типи даних і перетворення
   - Базові типи
     - #bold[`int`, `string`, `bool`, масиви `([])`, `list<T>`]
   - Конвертація типів
     - #bold[`int.Parse(), ToString()`]
5. Розуміння дебаг рекурсії
   - Дебагінг#footnote[Дебагінг - методичний процес пошуку та зменшення числа помилок] у Visual Studio / VS Code
])

#v(0.5cm)
#image("img/image.png")

#pagebreak()
#align(center)[#text(size: 17pt)[#bold[Поняття Рекурсія.]]]
  В #bold[`C#`] рекурсія не саме легке поняття. Давайте спочатку зрозуміємо що таке рекурсія


  #bold[Рекурсія] — це коли функція викликає сама себе, щоб розв'язати задачу, розбиваючи її на простіші підзадачі.


  Сама ідея дуже легка: #bold["Зроби щось, але спочатку зроби це саме для меншої частини задачі."]


  Розібравшись з самим поняттям відійдемо трохи в бік самої функції в #bold[`C#`]. В загалі функція створюється дуже легко якщо знати тему #bold[`Class`] і #bold[`Structure`]. Для початку ти створюєш тип данних для функції. Потім назву функції. Тоді ти в середині фігурних дужок задаєш змінні з типами данних ,які будуть передаватися в функцію. Приклад:
  #codly(
    languages: (
      csharp: (name: "csharp"),
    )
  )
  ```cs
  void Function(string text){
    ...
    return text;
  }
  ```


  Але якщо визвати ще раз цюсаму функцію в середині самої себе, то вийде помилка.
  ```cs
  void Function(string text){
    Function(text);
    return text;
  }
  ```


  #align(center)[#text(size: 17pt)[#bold[Чому видає помилку? Пряма рекурсія.]]] 
  Давайте розберемося з питанням: #bold["Чому воно буде видавати помилку?"]. Помилка буде через те що ми будемо постійно викликати функцію. Спочатку ми зайдемо в:
  ```cs
  void Function(string)
  ```
  потім ми зпустимося нижче до самого кода функції і знову викличемо цю саму функцію:
  ```cs
    Function(text)
  ```
  і ми ніколи недойдемо до #bold[`return text;`]. Тому щоб нам не попастися на таку помилку потрібно робити якусь умову за якої воно зупиниться. Наприклад:
  ```cs
  void Function(int integer){
    if(integer>0){
      int result = Function(integer-1);
    }
    return result;
  }

  Function(integer);
  ```
  У цьому прикладі у нас є #bold[умова] що ми будемо викликати функцію тоді коли число #bold[більше 0]. І коли будемо передавати параметри в функцію то будемо #bold[віднимати 1] щоб ми непопали в нескінечний цикл.

  Ми роздивилися приклад #bold[Прямої рекурсії (Direct Recursion)]. Але насправді є декілька видів рекурсій.\
  

  #align(center)[#text(size: 17pt)[#bold[Непряма рекурсія.]]]
  Наступний який ми роздивимося це #bold[Непряма рекурсія (Indirect Recursion)]. Її код буде виглядити так:
  ```cs
  public void FunctionA() {
      FunctionB();
  }

  public void FunctionB() {
      FunctionA();
  }
  ```
  Але ми теж неповинні забувати про умови за яких воно все зупиниться. Про неї нема що такого розсказати, тому що це та сама #bold[Пряма] рекурсія але визивається іншим методом.

  
  #align(center)[#text(size: 17pt)[#bold[Множинна рекурсія.]]]

  Далі роздивимося більш тяжку для поняття рекурсію: #bold[Множинна рекурсія (Multiple Recursion)]. Її буде тяжко зрозуміти ніж #bold[Лінійну] тому що в лінійній воно все іде один за одним, а в #bold[Множинній] воно робе різні розвилки. Тому щоб зрозуміти це потрібно приставити як дерево:
  #figure(
    image("img/image2.png"),
    caption: [Tree Recursion]
  )
  Тоді коли ми дойдемо до кінця дерева то ми буде вертатися назад у верх по дереву. Приклад #bold[Множинної] рекурсії:
  ```cs
  public int Fibonacci(int n) {
      if (n <= 1) return n;
      return Fibonacci(n - 1) + Fibonacci(n - 2);
  }
  ```
  Ми можемо побачити в `return` що викликаються дві функції і вони створюють різні розвилки.

  
  Щоб зрозуміти саму суть рекурсії її треба потренерувати на якихось задачках. Тільки тоді можна зрозуміти де і як її використовувати.

